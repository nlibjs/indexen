/* eslint-disable import/no-named-as-default-member */
import * as fs from 'fs';
import * as path from 'path';
import * as stream from 'stream';
import fg from 'fast-glob';

export interface IndexenProps {
  output?: string;
  include: Array<string>;
  exclude?: Array<string>;
  withoutExtension?: boolean;
}

export const indexen = async (props: IndexenProps) => {
  const writer = createWriter(props.output);
  for await (const line of generateCode(props)) {
    writer.write(`${line}\n`);
  }
  writer.end();
};

const createWriter = (output?: string) => {
  if (output) {
    return fs.createWriteStream(output);
  }
  return new stream.Writable({
    write(chunk: Buffer | string, _, callback) {
      process.stdout.write(chunk);
      callback();
    },
  });
};

export const generateCode = async function* ({
  include,
  exclude,
  output,
  withoutExtension,
}: IndexenProps): AsyncGenerator<string> {
  const history = new Set<string>();
  yield '// Generated by @nlib/indexen';
  if (output) {
    output = path.isAbsolute(output)
      ? output
      : path.join(process.cwd(), output);
  }
  const cwd = output ? path.dirname(output) : process.cwd();
  const getRelativePath = (file: string) => {
    let relativePath = path.relative(cwd, file).split(path.sep).join('/');
    if (!relativePath.startsWith('.')) {
      relativePath = `./${relativePath}`;
    }
    if (relativePath.endsWith('.mts')) {
      relativePath = `${relativePath.slice(0, -2)}js`;
    } else if (withoutExtension) {
      relativePath = relativePath.replace(/\.\w+$/, '');
    }
    return relativePath;
  };
  if (output) {
    history.add(getRelativePath(output));
  }
  for await (const file of fg.stream(include, {
    cwd,
    ignore: exclude,
    absolute: true,
  })) {
    const relativePath = getRelativePath(`${file}`);
    if (!history.has(relativePath)) {
      history.add(relativePath);
      yield `export * from '${relativePath}';`;
    }
  }
};
